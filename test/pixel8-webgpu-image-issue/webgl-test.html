<!DOCTYPE html>
<html>
<body>
<canvas></canvas>
</body>
<script type="module">
const img = new Image();
img.addEventListener('load', render);
img.crossOrigin = "";
img.src = "Plane_normal_PBR_Normal.png";

function render() {
  const vs = `#version 300 es
  out vec2 uv;
  void main() {
    vec2 pos[6];
    pos[0] = vec2( 0.0,  0.0);  // center
    pos[1] = vec2( 1.0,  0.0);  // right, center
    pos[2] = vec2( 0.0,  1.0);  // center, top
    pos[3] = vec2( 0.0,  1.0);  // center, top
    pos[4] = vec2( 1.0,  0.0);  // right, center
    pos[5] = vec2( 1.0,  1.0);  // right, top
    gl_Position = vec4(pos[gl_VertexID], 0, 1);
    uv = pos[gl_VertexID];
  }
  `;

  const fs = `#version 300 es
  precision highp float;
  in vec2 uv;
  out vec4 fragColor;
  uniform sampler2D tex;
  void main() {
    fragColor = texture(tex, uv);
  }
  `;

  const gl = document.querySelector("canvas").getContext("webgl2");
  const program = createProgram(gl, vs, fs);
  gl.useProgram(program);

  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  {
    const level = 0;
    const internalFormat = gl.RGBA;
    const width = 1;
    const height = 1;
    const border = 0;
    const format = gl.RGBA;
    const type = gl.UNSIGNED_BYTE;
    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                  format, type, img);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  }

  gl.clearColor(0.3, 0.3, 0.3, 1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  const primitiveType = gl.TRIANGLES;
  const offset = 0;
  const count = 6;
  gl.drawArrays(primitiveType, offset, count);
}

function createShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw new Error(gl.getShaderInfoLog(shader));
  }
  return shader;
}

function createProgram(gl, vs, fs, tf) {
  const program = gl.createProgram();
  gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vs));
  gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fs));
  if (tf) {
     gl.transformFeedbackVaryings(program, tf, gl.INTERLEAVED_ATTRIBS); // gl.SEPARATE_ATTRIBS);
  }
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    throw new Error(gl.getProgramInfoLog(program));
  }
  return program;
}
</script>
</html>